<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">AngWei's homepage</title>
<generator uri="https://github.com/jekyll/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml" />
<link rel="alternate" type="text/html" href="http://localhost:4000" />
<updated>2014-05-01T22:02:14+08:00</updated>
<id>http://localhost:4000/</id>
<author>
  <name>Ang Wei</name>
  <uri>http://localhost:4000/</uri>
  <email>weiang123@gmail.com</email>
</author>


<entry>
  <title type="html"><![CDATA[Ruby变量作用域]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/Ruby%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/" />
  <id>http://localhost:4000/Ruby变量作用域</id>
  <published>2013-12-30T00:00:00+08:00</published>
  <updated>2013-12-30T00:00:00+08:00</updated>
  <author>
    <name>Ang Wei</name>
    <uri>http://localhost:4000</uri>
    <email>weiang123@gmail.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;ruby&quot;&gt;Ruby中变量的作用域&lt;/h1&gt;

&lt;h2 id=&quot;variable-scope&quot;&gt;1 什么是变量作用域(variable scope)&lt;/h2&gt;
&lt;p&gt;作用域定义了一个变量在程序中的可访问范围。Ruby中有四种类型的变量作用域：&lt;em&gt;局部(local),全局(global),实例(instance)和类(class)&lt;/em&gt;。通过在变量名前加上不同的特殊字符来声明不同的变量类型。如下表：&lt;/p&gt;
&lt;table&gt; 
	&lt;tr&gt;
		&lt;td&gt;变量名前缀&lt;/td&gt;
		&lt;td&gt;作用域&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;$&lt;/td&gt;
		&lt;td&gt;全局变量&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;@&lt;/td&gt;
		&lt;td&gt;实例变量&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;[a-z]或_&lt;/td&gt;
		&lt;td&gt;局部变量&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;[A-Z]&lt;/td&gt;
		&lt;td&gt;常量&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;@@&lt;/td&gt;
		&lt;td&gt;类变量&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;除此之外，Ruby还有两个不能被赋值的&lt;em&gt;伪变量(pseudo-variables)&lt;/em&gt;，&lt;em&gt;nil&lt;/em&gt;和&lt;em&gt;self&lt;/em&gt;。&lt;em&gt;nil&lt;/em&gt;用来表示未初始化的变量，&lt;em&gt;self&lt;/em&gt;用来引用正在执行的对象。&lt;/p&gt;

&lt;h2 id=&quot;ruby-1&quot;&gt;2 检查Ruby中的变量作用域&lt;/h2&gt;
&lt;p&gt;通过观察变量名可以区分不同变量的作用域。但有些时候需要通过编程的方式来获得一个变量的作用域。Ruby提供了一个有效的函数&lt;em&gt;define?&lt;/em&gt;来达到这个目的。&lt;em&gt;define?&lt;/em&gt;函数返回被引用变量的作用域。如果变量在当前上下文(current context)中没用被定义，则&lt;em&gt;define?&lt;/em&gt;返回&lt;em&gt;nil&lt;/em&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = 10
=&amp;gt; 10
defined? x
=&amp;gt; &quot;local-variable&quot;

$x = 10
=&amp;gt; 10
defined? $x
=&amp;gt; &quot;global-variable&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;rubylocal-variables&quot;&gt;3 Ruby局部变量(local variables)&lt;/h2&gt;
&lt;p&gt;局部变量只在声明它的代码结构中可以被存取。例如，在方法(method)或循环结构(loop)中声明的变量不可以从该结构之外存取。局部变量名必须以小写字母或’_‘开头。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;loopcounter = 10
_LoopCounter = 20
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;rubyglobal-variables&quot;&gt;4 Ruby全局变量(global variables)&lt;/h2&gt;
&lt;p&gt;全局变量可在任何地方被存取，即使在全局变量被声明之前。全局变量名必须以’$’为前缀。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$welcone = &quot;Welcone to Ruby Essentials&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但使用全局变量是不被鼓励的。全局变量的问题在于：不仅它在代码的任何地方可见，而且它可以在代码的任何地方被修改。这会使得追踪’bugs’变得非常困难。
但是，了解一些Ruby预定义的全局变量是大有好处的。这些全局变量可以帮助Ruby开发者了解当前的Ruby开发环境。这里有张关于这些全局变量的简要总结：&lt;/p&gt;
&lt;table&gt;
	&lt;tr&gt;
		&lt;td&gt;变量名&lt;/td&gt;
		&lt;td&gt;变量值&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr /&gt;
		&lt;td&gt;$@&lt;/td&gt;
		&lt;td /&gt;最近发生错误的位置
	&lt;tr /&gt;
		&lt;td /&gt;$_
		&lt;td /&gt;上一次被gets读取的字符串
	&lt;tr /&gt;
		&lt;td /&gt;$.
		&lt;td /&gt;解释器上一次读取的行号
	&lt;tr /&gt;
		&lt;td /&gt;$&amp;amp;
		&lt;td /&gt;上一次被regexp匹配的字符串
	&lt;tr /&gt;
		&lt;td /&gt;$~
		&lt;td /&gt;上一次作为字表达式数组匹配的regexp
	&lt;tr /&gt;
		&lt;td /&gt;$n
		&lt;td /&gt;上一次匹配中的第n个子表达式(等同于$~[n])
	&lt;tr /&gt;
		&lt;td /&gt;$=
		&lt;td /&gt;大小写无关标志
	&lt;tr /&gt;
		&lt;td /&gt;$/
		&lt;td /&gt;输入记录分割符
	&lt;tr /&gt;
		&lt;td /&gt;$\
		&lt;td /&gt;输出记录分割符
	&lt;tr /&gt;
		&lt;td /&gt;$0
		&lt;td /&gt;正在执行的Ruby脚本名
	&lt;tr /&gt;
		&lt;td /&gt;$*
		&lt;td /&gt;调用脚本是的命令行参数
	&lt;tr /&gt;
		&lt;td /&gt;$$
		&lt;td /&gt;Ruby解释器的pid(进程号)
	&lt;tr /&gt;
		&lt;td /&gt;$?
		&lt;td /&gt;上一个执行子进程的退出状态
&lt;/table&gt;
&lt;p&gt;例如，执行&lt;em&gt;gets&lt;/em&gt;方法来从键盘获取输入，再用$_变量来提取从键盘键入的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;irb(main):005:0&amp;gt;gets
hello
=&amp;gt; &quot;hello\n&quot;
irb(main):006:0&amp;gt;$_
=&amp;gt; &quot;hello\n&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然也可以获得Ruby解释器的进程号：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;irb(main):007:0&amp;gt;$$
=&amp;gt; 17403
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;rubyclass-variables&quot;&gt;5 Ruby类变量(class variables)&lt;/h2&gt;
&lt;p&gt;类变量被该类所实例化的所有对象共享。这意味着只有一个变量存在，而这个变量为所有实例对象所共享。这也意味着一个对象对该变量的修改也会改变其他实例对象的该变量值。
另一种观点将类变量看成是一个单独类中的全局变量。类变量的声明必须以’@@’为前缀。类变量必须在创建时初始化。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@@total = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;rubyinstance-variables&quot;&gt;6 Ruby实例变量(instance variables)&lt;/h2&gt;
&lt;p&gt;实例变量和类变量很类似，只是实例变量为特定实例对象所私有。例如如果一个类包含一个实例变量，&lt;em&gt;@total&lt;/em&gt;，如果一个实例对象改变了&lt;em&gt;@total&lt;/em&gt;的值，这个改变只局限于改变这个变量的类实例对象中。其他的同类对象拥有自己私有的，独立于其他对象的对其改变的副本。
Ruby中实例变量以’@’为前缀：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@total = 10
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;rubyconstant-variabes&quot;&gt;7 Ruby常量变量(constant variabes)&lt;/h2&gt;
&lt;p&gt;Ruby中的常量是一旦被赋值后就不“应该”被改变的变量。但是Ruby不同于大多数编程语言，它允许常量在声明后依然可以被修改。Ruby解释器只是弹出一个警告信息来表示轻微的抗议。
声明在类或模块(module)中的常量可以在类或模块的上下文中的任何地方使用。声明在类和模块之外的常量具有全局作用域。&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/Ruby%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/&quot;&gt;Ruby变量作用域&lt;/a&gt; was originally published by Ang Wei at &lt;a href=&quot;http://localhost:4000&quot;&gt;AngWei's homepage&lt;/a&gt; on December 30, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[G++'s two-stage name lookup]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/reserved/gs-two-stage-name-lookup/" />
  <id>http://localhost:4000/reserved/gs-two-stage-name-lookup</id>
  <published>2013-12-17T00:00:00+08:00</published>
  <updated>2013-12-17T00:00:00+08:00</updated>
  <author>
    <name>Ang Wei</name>
    <uri>http://localhost:4000</uri>
    <email>weiang123@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;转自:&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Name-lookup.html&quot;&gt;http://gcc.gnu.org/onlinedocs/gcc/Name-lookup.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The C++ standard prescribes that all names that are not dependent on template parameters are bound to their present definitions when parsing a template function or class. Only names that are dependent are looked up at the point of instantiation. For example, consider&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   void foo(double);
 
   struct A {
     template &amp;lt;typename T&amp;gt;
     void f () {
       foo (1);        // 1
       int i = N;      // 2
       T t;
       t.bar();        // 3
       foo (t);        // 4
     }
 
     static const int N;
   };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, the names foo and N appear in a context that does not depend on the type of T. The compiler will thus require that they are defined in the context of use in the template, not only before the point of instantiation, and will here use ::foo(double) and A::N, respectively. In particular, it will convert the integer value to a double when passing it to ::foo(double).&lt;/p&gt;

&lt;p&gt;Conversely, bar and the call to foo in the fourth marked line are used in contexts that do depend on the type of T, so they are only looked up at the point of instantiation, and you can provide declarations for them after declaring the template, but before instantiating it. In particular, if you instantiate A::f&lt;int&gt;, the last line will call an overloaded ::foo(int) if one was provided, even if after the declaration of struct A.&lt;/int&gt;&lt;/p&gt;

&lt;p&gt;This distinction between lookup of dependent and non-dependent names is called two-stage (or dependent) name lookup. G++ implements it since version 3.4.&lt;/p&gt;

&lt;p&gt;Two-stage name lookup sometimes leads to situations with behavior different from non-template codes. The most common is probably this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   template &amp;lt;typename T&amp;gt; struct Base {
     int i;
   };
 
   template &amp;lt;typename T&amp;gt; struct Derived : public Base&amp;lt;T&amp;gt; {
     int get_i() { return i; }
   }; In get_i(), i is not used in a dependent context, so the compiler will look for a name declared at the enclosing namespace scope (which is the global scope here). It will not look into the base class, since that is dependent and you may declare specializations of Base even after declaring Derived, so the compiler can't really know what i would refer to. If there is no global variable i, then you will get an error message.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to make it clear that you want the member of the base class, you need to defer lookup until instantiation time, at which the base class is known. For this, you need to access i in a dependent context, by either using this-&amp;gt;i (remember that this is of type Derived&lt;t&gt;*, so is obviously dependent), or using Base&lt;t&gt;::i. Alternatively, Base&lt;t&gt;::i might be brought into scope by a using-declaration.&lt;/t&gt;&lt;/t&gt;&lt;/t&gt;&lt;/p&gt;

&lt;p&gt;Another, similar example involves calling member functions of a base class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   template &amp;lt;typename T&amp;gt; struct Base {
       int f();
   };
 
   template &amp;lt;typename T&amp;gt; struct Derived : Base&amp;lt;T&amp;gt; {
       int g() { return f(); };
   }; Again, the call to f() is not dependent on template arguments (there are no arguments that depend on the type T, and it is also not otherwise specified that the call should be in a dependent context). Thus a global declaration of such a function must be available, since the one in the base class is not visible until instantiation time. The compiler will consequently produce the following error message:

   x.cc: In member function `int Derived&amp;lt;T&amp;gt;::g()':
   x.cc:6: error: there are no arguments to `f' that depend on a template
      parameter, so a declaration of `f' must be available
   x.cc:6: error: (if you use `-fpermissive', G++ will accept your code, but
      allowing the use of an undeclared name is deprecated) To make the code valid either use this-&amp;gt;f(), or Base&amp;lt;T&amp;gt;::f(). Using the -fpermissive flag will also let the compiler accept the code, by marking all function calls for which no declaration is visible at the time of definition of the template for later lookup at instantiation time, as if it were a dependent call. We do not recommend using -fpermissive to work around invalid code, and it will also only catch cases where functions in base classes are called, not where variables in base classes are used (as in the example above).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that some compilers (including G++ versions prior to 3.4) get these examples wrong and accept above code without an error. Those compilers do not implement two-stage name lookup correctly.&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/reserved/gs-two-stage-name-lookup/&quot;&gt;G++'s two-stage name lookup&lt;/a&gt; was originally published by Ang Wei at &lt;a href=&quot;http://localhost:4000&quot;&gt;AngWei's homepage&lt;/a&gt; on December 17, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Sublime text cmd]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/reserved/sublime-text-cmd/" />
  <id>http://localhost:4000/reserved/sublime-text-cmd</id>
  <published>2013-11-13T00:00:00+08:00</published>
  <updated>2013-11-13T00:00:00+08:00</updated>
  <author>
    <name>Ang Wei</name>
    <uri>http://localhost:4000</uri>
    <email>weiang123@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;Sublime Text 2 快捷键用法大全&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Ctrl+D 选词 （反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑）
Ctrl+G 跳转到相应的行
Ctrl+J 合并行（已选择需要合并的多行时）
Ctrl+L 选择整行（按住-继续选择下行）
Ctrl+M 光标移动至括号内开始或结束的位置
Ctrl+T 词互换
Ctrl+U 软撤销
Ctrl+P 查找当前项目中的文件和快速搜索；输入 @ 查找文件主标题/函数；或者输入 : 跳转到文件某行；
Ctrl+R 快速列出/跳转到某个函数
Ctrl+K Backspace 从光标处删除至行首
Ctrl+KB 开启/关闭侧边栏
Ctrl+KK 从光标处删除至行尾
Ctrl+KT 折叠属性
Ctrl+KU 改为大写
Ctrl+KL 改为小写
Ctrl+K0 展开所有
Ctrl+Enter 插入行后（快速换行）
Ctrl+Tab 当前窗口中的标签页切换

Ctrl+Shift+A 选择光标位置父标签对儿
Ctrl+Shift+D 复制光标所在整行，插入在该行之前
ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找
Ctrl+Shift+K 删除整行
Ctrl+Shift+L 鼠标选中多行（按下快捷键），即可同时编辑这些行
Ctrl+Shift+M 选择括号内的内容（按住-继续选择父括号）
Ctrl+Shift+P 打开命令面板
Ctrl+Shift+/ 注释已选择内容
Ctrl+Shift+↑可以移动此行代码，与上行互换
Ctrl+Shift+↓可以移动此行代码，与下行互换
Ctrl+Shift+[ 折叠代码
Ctrl+Shift+] 展开代码
Ctrl+Shift+Enter 光标前插入行
Ctrl+PageDown 、Ctrl+PageUp 文件按开启的前后顺序切换

Ctrl+Z 撤销
Ctrl+Y 恢复撤销
Ctrl+F2 设置书签
Ctrl+/ 注释整行（如已选择内容，同“Ctrl+Shift+/”效果）
Ctrl+鼠标左键 可以同时选择要编辑的多处文本

Shift+鼠标右键（或使用鼠标中键）可以用鼠标进行竖向多行选择
Shift+F2 上一个书签
Shift+Tab 去除缩进
Alt+Shift+1~9（非小键盘）屏幕显示相等数字的小窗口

Alt+. 闭合当前标签
Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑

Tab 缩进 自动完成
F2 下一个书签
F6 检测语法错误
F9 行排序(按a-z)
F11 全屏模式
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1、安装包控制（Package Control）&lt;/p&gt;

&lt;p&gt;打开Sublime Text 2，按快捷键 ctrl+` 或者点击 Tools → Command Palette 调出控制台Console；
将以下代码复制粘贴进命令行后回车：
import urllib2,os;pf=’Package Control.sublime-package’;ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp)elseNone;open(os.path.join(ipp,pf),’wb’).write(urllib2.urlopen(‘http://sublime.wbond.net/’+pf.replace(‘ ‘,’%20’)).read())
重新启动Sublime Text 2，如果在Preferences → Package Settings 中看到 Package Control 这一项，就说明安装成功了。&lt;/p&gt;

&lt;p&gt;2、安装Alignment插件
对于喜欢整齐的玛民来说，这不失为一个省事的插件。该插件可以通过上面安装好的 Package Control 来安装：
按ctrl + shift + P调出命令面板；
输入 install 调出 Package Control：Install Package 选项，并回车；
输入Alignment，选中并按回车安装；
重启Sublime Text 2，选中文本并按ctrl + alt + a 就可以进行对齐操作了。&lt;/p&gt;

&lt;p&gt;3、安装 Soda 主题
这里的主题不同于针对代码的 color scheme，而是针对Sublime Text 2该软件本身的主题，该主题也可以通过万能的 Package Control 来安装。
按ctrl + shift + P调出命令面板；
输入 install 调出 Package Control：Install Package 选项，并回车；
输入 theme soda 选中后回车即可安装；
安装完之后要激活主题，打开 Preferences → Global Settings – User，加上以下代码保存即可生效：
“theme”: “Soda Light.sublime-theme” 或者 “theme” : “Soda Dark.sublime-theme”&lt;/p&gt;

&lt;p&gt;4、安装cTags插件
首先，从Ctags官网下载压缩包下来，解压到电脑的某个地方，比如“C:\Program Files\ctags”，然后把cTags添加到系统变量里去：
在“我的电脑”右键属性 → 高级 → 环境变量 → 在“系统变量”里找到“Path”，点击“编辑” → 把“;C:\Program Files\ctags”（不包括双引号）复制到最后 → 最后一路“确定”保存。
然后通过 Package Control 来安装 cTags 插件：
按ctrl + shift + P调出命令面板；
输入 install 调出 Package Control：Install Package 选项，并回车；
输入 ctags 选中后回车即可安装。
安装完之后，在项目的当前目录下按ctrl + t, ctrl + r，会生成.tags的文件。当光标停留在某个函数上时，按快捷键 ctrl+t, ctrl+t就可以打开函数所在的文件，并跳转到相应的位置了。&lt;/p&gt;

&lt;p&gt;PS： 安装这个插件折腾了我蛮久，主要是不知道还要从ctags官网下载压缩包，以及修改系统的变量，后来还是一博友给我发的国外的参考资料才知道要这样配置 的。刚开始知道这软件之所以没用是因为没有像eclipse可以追踪函数的功能，后来才知道可以通过安装cTags插件来实现。装上此功能后，就更喜欢用 Sublime Text 2了。&lt;/p&gt;

&lt;p&gt;5、jsFormat插件
格式化js：选中一段文本，control+alt+f。&lt;/p&gt;

&lt;p&gt;6、DocBlockr
在JS函数上方输入/**，然后回车，doc就生成好了非常好用。&lt;/p&gt;

&lt;p&gt;7、sublime-jslint
打开一个js文件，control+j，即可输出jsLint检查的结果。打开Packages目录，找到插件目录sublime-jslint，打开 sublime-jslint.sublime-settings文件，可以修改jsLint配置，还可以配置文件保存时自动检查等，如：
{ // Path to the jslint jar. // Leave blank to use bundled jar. “jslint_jar”: “”,   // Options pass to jslint. // Jerry Qu注：全部可用配置参考这里，https://github.com/fbzhong/sublime-jslint/wiki/Available-jslint4java-options “jslint_options”: “–encoding utf-8 –bitwise –browser –cap –css –devel –debug –evil –forin –fragment –on –sub –white –windows –sloppy”,   // Ignore errors, regex. “ignore_errors”: [ // “Expected an identifier and instead saw ‘undefined’ (a reserved word)” ],   // run jslint on save. “run_on_save”: false,   // debug flag. “debug”:false }&lt;/p&gt;

&lt;p&gt;8、SideBarEnhancements
推荐通过 Package Control 安装 SideBarEnhancements 这个插件，可以大大加强在侧栏目录树中右键的选项&lt;/p&gt;

&lt;p&gt;9、Zen Coding
10、jQuery Package for sublime Text
11、Clipboard History
12、Bracket Highlighter
13、GBK to UTF8
14、Git&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/reserved/sublime-text-cmd/&quot;&gt;Sublime text cmd&lt;/a&gt; was originally published by Ang Wei at &lt;a href=&quot;http://localhost:4000&quot;&gt;AngWei's homepage&lt;/a&gt; on November 13, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[VIM COPY]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/reserved/vim-copy/" />
  <id>http://localhost:4000/reserved/vim-copy</id>
  <published>2013-11-08T00:00:00+08:00</published>
  <updated>2013-11-08T00:00:00+08:00</updated>
  <author>
    <name>Ang Wei</name>
    <uri>http://localhost:4000</uri>
    <email>weiang123@gmail.com</email>
  </author>
  <content type="html">&lt;h1 id=&quot;vim&quot;&gt;VIM复制粘贴大全&lt;/h1&gt;
&lt;p&gt;转自：&lt;a href=&quot;http://lsong17.spaces.live.com/blog/cns!556C21919D77FB59!603.entry&quot;&gt;http://lsong17.spaces.live.com/blog/cns!556C21919D77FB59!603.entry&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;内容：
用vim这么久 了，始终也不知道怎么在vim中使用系统粘贴板，通常要在网上复制一段代码都是先gedit打开文件，中键粘贴后关闭，然后再用vim打开编辑，真的不 爽；上次论坛上有人问到了怎么在vim中使用系统粘贴板，印象里回复很多，有好几页的回复却没有解决问题，今天实在受不了了又在网上找办法，竟意外地找到 了，贴出来分享一下。&lt;/p&gt;

&lt;p&gt;如果只是想使用系统粘贴板的话直接在输入模式按Shift+Inset（粘贴）就可以了，下面讲一下vim的粘贴板的基础知识，有兴趣的可以看看，应该会有所收获的。
vim帮助文档里与粘贴板有关的内容如下：
vim有12个粘贴板，分别是0、1、2、…、9、a、“、＋；用:reg命令可以查看各个粘贴板里的内容。在vim中简单用y只是复制到“（双引号)粘贴板里，同样用p粘贴的也是这个粘贴板里的内容；&lt;/p&gt;

&lt;p&gt;要将vim的内容复制到某个粘贴板，需要退出编辑模式，进入正常模式后，选择要复制的内容，然后按”Ny（注意带引号）完成复制，其中N为粘贴板号(注意是按一下双引号然后按粘贴板号最后按y)，例如要把内容复制到粘贴板a，选中内容后按”ay就可以了，有两点需要说明一下：
“号粘贴板（临时粘贴板）比较特殊，直接按y就复制到这个粘贴板中了，直接按p就粘贴这个粘贴板中的内容；
+号粘贴板是系统粘贴板，用”+y将内容复制到该粘贴板后可以使用Ctrl＋V将其粘贴到其他文档（如firefox、gedit）中，同理，要把在其他地方用Ctrl＋C或右键复制的内容复制到vim中，需要在正常模式下按”+p；
要将vim某个粘贴板里的内容粘贴进来，需要退出编辑模式，在正常模式按”Np，其中N为粘贴板号，如上所述，可以按”5p将5号粘贴板里的内容粘贴进来，也可以按”+p将系统全局粘贴板里的内容粘贴进来。&lt;/p&gt;

&lt;p&gt;注意：在我这里，只有vim.gtk或vim.gnome才能使用系统全局粘贴板，默认的vim.basic看不到+号寄存器。安装vim.gnome使用apt-get install vim-gnome，然后vim自动会链接到vim.gnome。&lt;/p&gt;

&lt;p&gt;下面是vim复制粘贴的基本命令：
	yy复制游标所在行整行。或大写一个Y。 
	2yy或y2y复制两行。 ㄟ ，请举一反三好不好！ :-) 
	y^复制至行首，或y0。不含游标所在处字元。 
	y$复制至行尾。含游标所在处字元。 
	yw复制一个word。 
	y2w复制两个字（单词）。 
	yG复制至档尾。 
	y1G复制至档首。 
	p小写p代表贴至游标后（下）。 
	P大写P代表贴至游标前（上）。&lt;/p&gt;

&lt;p&gt;复制单个字符
首选进入正常模式（按ESC就行）
然后按ｖ（指定粘贴板为”1v 引号不能少），进入visual方式，然后就可以移动方向键选中文本，然后按y，就拷贝完成，
如果你要从光标处开始复制 4 个字符，可以按 4yl (复制光标后的)（”14yl）(“110yl 后面10个字符),4yh(复制光标前的) ，就复制了4个字符到缓冲区中了，
按下来就可以用 p （指定粘贴板为”1v 引号不能少）命令随便粘贴了（1为指下粘贴板名）&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/reserved/vim-copy/&quot;&gt;VIM COPY&lt;/a&gt; was originally published by Ang Wei at &lt;a href=&quot;http://localhost:4000&quot;&gt;AngWei's homepage&lt;/a&gt; on November 08, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Finding Comments in Source Code Using Regular Expressions]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/reserved/finding-comments-in-source-code-using-regular-expressions/" />
  <id>http://localhost:4000/reserved/finding-comments-in-source-code-using-regular-expressions</id>
  <published>2013-11-08T00:00:00+08:00</published>
  <updated>2013-11-08T00:00:00+08:00</updated>
  <author>
    <name>Ang Wei</name>
    <uri>http://localhost:4000</uri>
    <email>weiang123@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;转自：&lt;a href=&quot;http://ostermiller.org/findcomment.html&quot;&gt;http://ostermiller.org/findcomment.html&lt;/a&gt;&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/reserved/finding-comments-in-source-code-using-regular-expressions/&quot;&gt;Finding Comments in Source Code Using Regular Expressions&lt;/a&gt; was originally published by Ang Wei at &lt;a href=&quot;http://localhost:4000&quot;&gt;AngWei's homepage&lt;/a&gt; on November 08, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[11个很少人知道但很有用的Linux命令]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/reserved/11/" />
  <id>http://localhost:4000/reserved/11</id>
  <published>2013-10-30T00:00:00+08:00</published>
  <updated>2013-10-30T00:00:00+08:00</updated>
  <author>
    <name>Ang Wei</name>
    <uri>http://localhost:4000</uri>
    <email>weiang123@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;转自：&lt;a href=&quot;http://blog.jobbole.com/50632/&quot;&gt;http://blog.jobbole.com/50632/&lt;/a&gt;&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/reserved/11/&quot;&gt;11个很少人知道但很有用的Linux命令&lt;/a&gt; was originally published by Ang Wei at &lt;a href=&quot;http://localhost:4000&quot;&gt;AngWei's homepage&lt;/a&gt; on October 30, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[job]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/reserved/job/" />
  <id>http://localhost:4000/reserved/job</id>
  <published>2013-10-26T00:00:00+08:00</published>
  <updated>2013-10-26T00:00:00+08:00</updated>
  <author>
    <name>Ang Wei</name>
    <uri>http://localhost:4000</uri>
    <email>weiang123@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;写这篇文章源于某条微博评论，原内容大概是一个快40岁的人还在当程序员写代码，评论内容大概是：有些人就喜欢当程序员写代码，无可厚非。但是，现实情况中是否真的能做到“无可厚非”呢？我思考了一阵子以后，就有了这篇文章，希望与所有职场人共勉。&lt;/p&gt;

&lt;p&gt;首先我要申明一点，我不是砖家，也不是牛人，我只是一名普通的IT从业者，本文只是我对我们IT人的职业生涯规划的一些观点和意见，如果大家有不同意见，或者觉得我的观念欠妥，欢迎讨论，但是拒绝谩骂、吵架和攻击，谢谢。&lt;/p&gt;

&lt;p&gt;简单介绍一下我的情况，我是03级的本科生，07年毕业后一直从事软件方面工作，现在是一名项目经理，到今天为止，我差不多有5年半的工作经验了(我是07年3月就进了公司)。那么为什么我现在会对职业生涯规划有感悟呢？因为随着时间的增长，我越来越觉得我们混职场的IT人（当然不限于软件行业，只要是职场人）如果没有一个很好的职业规划，那么随着时间的流逝，我们逝去的不仅仅是年华那么简单；当你某天猛然发现当年同一起跑线的同窗朋友，现在跟你的差距大到让你愕然时，你就真的很难很难逆转这种局面了。当然，我这样抽象的说，很多人无法感受到这种紧迫感和恐惧感，下面我分3个方面来说明职业生涯规划的重要性。&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;第一，职业生涯规划是事业的导航&lt;/h1&gt;

&lt;p&gt;首先我们搞清楚，事业是什么？？乔布斯的苹果公司，叫事业；你每天上班路上卖油条豆浆的大妈的早饭摊，叫事业，同样，我们IT人每天上班时，在格子间干的事情，那也叫事业！很多人总是觉得自己是个小职员，每天都做着小事情，似乎事业这种词汇应该总是伴随着老总、资金、企业这种概念的，所以，反正我只是个小职员，反正我又不是名校毕业，反正我的学历一般，就算规划的再灿烂，也只是画饼充饥而已，还不如每天耕好自己的一亩三分田，剩下的就是老婆孩子热炕头了…(中枪的同学举个手看..)&lt;/p&gt;

&lt;p&gt;我认为这种思想最大的毛病就在于自我否定。我举个例子，CS 这游戏大部分人都应该玩过吧，你进一个主机开始游戏以后最多的动作是什么？？不是开枪，不是到处走，不是换子弹，而是按tab查看排名！每个人都想多杀点人，多拿点分，进入警察或者土匪榜的前三甚至第一，难道你会说：反正我技术一般，还不如给别人做嫁衣，让别人杀了拿分呢？所以，我们在职场混，也好像在玩一个现实版的游戏，那么我们的目的就是拿高分，也就是向更高的目标进发，无限的接近目标，甚至超越目标，而职业生涯规划，就是你达到目标的一个个里程碑，它会每时每刻为你指明你的方向，让你明确你的目标，并一步一步走下去，所以职业生涯规划绝对不是画饼充饥。&lt;/p&gt;

&lt;p&gt;当然，你的目标必须切合实际，但是也不能太过于保守，甚至可以是一种阶段型的规划。比如我，我07年进公司是程序员，程序员的地位好工作大家应该是再熟悉不过了，我本科读的是个三类大学，还不是软件本职专业，但是有幸能找到这样一份工作，我还是很感激老板的。既来之则安之，学习技术技能，累积经验，同时关心行业的发展前进和自身的晋升路线。当时我了解到，程序员的发展一般来说是这样，程序员→软件工程师→架构师→系统分析师(技术路线)或者项目管理师(管理路线)，最终到达技术总监，或者项目总监甚至CTO、COO或者CIO等高级职位。也有程序员后来进入测试领域，后来成为QA或者QC，最后成为质量总监等。我根据我本身的性格，兴趣，和切合自身的发展方向等多方面因素考虑，定下来自己走项目管理的路线，我给自己的职业规划是这样：程序员→软件工程师→项目主管→项目经理→项目总监→CIO；而我也确实一步步正在实现了自己的规划，能够到达今天的这个位置，职业规划起了相当大的作用。它总是在不停的指引和鞭笞我向目标进发，而我自己也从来没有感到彷徨，没有困惑过，因为我有目标，有规划，有方向，这就是职业规划的力量！因此，不要因为你现在的微不足道而放弃对自己的规划，饭要一口一口吃，只要你做好切实可行适合于你的规划，并且一步一步的按着规划来做，达到目标就只是时间问题而已了！&lt;/p&gt;

&lt;p&gt;另外有一点我想说一下，就是很多人认为“计划赶不上变化”所以这种规划性的东西就算写的再好以后也可能会“赶不上变化”。我认为吧，如果你还是在学校的学生，可以有这种想法，但是如果你已经入了职场，那么就别这样想了，除非你想做一个经常转行的人，那我就没办法了。我当年在学校被辅导员逼着写职业生涯设计（比赛）的时候，我也有过这种想法，并且觉得职业生涯设计时个扯淡的事情。但是后来工作后发现这个还是非常重要的，如我上文所述，是个不可或缺的东西，至少我这么认为，也确实给我带来了很好的收获。这个毕竟是个在你职业中导航的东西，就算有些和你的现实生活有些避免不了的小差距，但是至少一份好的职业生涯规划在大体上会给你一个方向性的指导，不至于让你在某些时候感到迷茫。&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;第二，职业规划能给你带来你想要的东西&lt;/h1&gt;

&lt;p&gt;有句老话叫做“无欲则刚”，我承认我是俗人，我没有那么坦然淡定的心态，我在某些时候甚至俗到想要鱼和熊掌兼得。但是，这错了吗？？答案当然是没有。只要通过正当途径，你获得的越多，反而证明你越有本事。&lt;/p&gt;

&lt;p&gt;有很多程序员总是有这样想法：现在我是不行，但是等过几年我有经验了，工资和职位自然就上去了。暂且不说这种想法对还是错，我先讲个真实的故事。我曾经有个手下，叫小Y好了，是09年的应届生，被公司招进来后安排在我手下当程序员。相处一段时间后，我发现小Y这个人能力很一般，也不愿意利用空闲时间学习（因为是吃技术这碗饭，所以我觉得学习真的很重要，后面会详谈），而且干活很粗糙，写的代码往往总是要我返工修改。当年年底我给他的绩效考评比较低，因此第二年加薪的时候，他相较于他的在其他部门当程序员的朋友要低很多（当时是一批招的），所以对我对公司有很大意见，后来我找他谈，我就很直接问他凭什么要求加薪水平跟别人一样？他回答我说他工资太低，来了一年还相当于应届本科水平。我说可是你的能力比某些应届生要差很多（当时我有另一个2010年本科应届生手下，能力非常强，起码有2年经验程序员的水平)。他就回答我说他有经验。所以看到这里，各位也也应该猜到了结局，不错，后来小Y走人了。&lt;/p&gt;

&lt;p&gt;我讲这个故事看似和职业规划没有太大关系，实际上我觉得还是能说明一些问题的。也就是说，经验重不重要呢？？毫无疑问，在任何行业，经验都是非常重要的东西，而且用钱也买不来。但是大家切记，不要认为单凭“经验”这东西就可以无敌了！比如你喜欢搞技术，你想以后当个牛X的架构师，但是你仅仅靠当程序员而不去学习相关知识，就算累积10年编码经验，也充其量只能到软件工程师的程度，到架构师的那道坎很难跨越过去。那么你想得到的，终究还是水中月，看起来很近，实际上还是很远。&lt;/p&gt;

&lt;p&gt;有些朋友会说：我不想的到什么，我不想要什么，现在这样挺好，我也挺喜欢写代码的，职业生涯规划对我来说也就没什么用。好吧，我承认，这样的朋友境界比较高，我自愧不如。但是你要明白，你是生存在社会里面，你不是一个独立的个体，你有家庭，你将来会上有老下有小，甚至你还要担负你老婆的生活，我不知道当你的父母需要你养老，你的房车需要你还贷，你的儿女需要你缴学费，乃至于你的儿子需要娶媳妇（如果是女儿就赚了，哈哈）的时候还能不能有这种淡定的心态呢？？还有，你们想想，当你30好几岁了，快40岁了，还和20出头的年轻人在一起写代码的时候，会是什么感觉？？他们年轻力盛，充满激情，跟你当年一样，熬通宵，连续工作10小时，不规律吃饭，哼都不会哼一声，但是你呢？当你体力下降，记忆力下降，逻辑分析能力下降，思维开始迟钝的时候，你觉得你还拼的过他们吗？？当你的公司为了维持一个仅仅有“经验”而其他各方面都不如年轻人，却还要支付高于年轻人一大笔工资的中年人的时候，你觉得公司会怎么做？我不知道各位看到这里有什么想法，反正我每每想到这种情况，我的后背会发凉，我会觉得很恐怖，真的很恐怖！所以你最好还是收起那份淡定，去努力的博取你所必须要博取的东西吧，职位，薪酬等等！想要这些，说容易也容易，做好职业生涯规划，自然总有一天能够达到目标。&lt;/p&gt;

&lt;p&gt;当你做好了职业规划后，给自己定下一条线性的职场进化路线图，定下每个里程碑，每个小的关键点，包括为了达到这些里程碑和关键点所需要做的事情，或者需要累积的知识，那么这样在你日常工作中，你不会胡乱的去累积所谓的“经验”，而是有针对性的，有目的的去学习或者去巩固或者去锻炼你的能力，这样一来，日积月累，你就自然而然的按照职业规划的线路走下去了，反过来说，你就一步一步的实现了自己的目标，得到了自己想要的东西。比如我当年给自己顶下项目管理这条路，我在平时工作中就非常注意锻炼这方面的能力，比如跟客户沟通，比如撰写文档，比如协调团队，等等，另外，我也强制要求自己学习项目管理方面的知识，强化管理的理念和能力，并将理论用于实践，将书本上学到的项目管理知识，比如进度管理，成本管理，范围管理用于我现实的项目中，这样就形成了一种良性的循环，我学到的越来越多，工作也越做越好了。那么自然而然的我就从软件工程师到项目主管，再到现在的项目经理，我想要的，我确实得到了。&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;第三，职业生涯规划能够让你持续的学习&lt;/h1&gt;

&lt;p&gt;前面我在说小Y的例子的时候说到过，作为一名技术领域的人，持续学习是非常重要的，这是你在这片残酷竞争的环境下生存乃至拔尖的唯一方式。前面我说过，仅仅靠工作中的那点经验累积，对于我们的发展是肯定不够的，必须要通过充电来补充知识，才能推动我们的晋升。而很多搞软件的都面临一个问题，就是没有动力去充电，一想到看书就头大，还是写代码比较有意思。&lt;/p&gt;

&lt;p&gt;其实大多数人都明白学习的重要性，只是真正能够做到持续学习的人实在是少之又少，你扪心自问，你每天看书（技术相关）时间有多少？大多数人少于两小时的，可能更多人会选择逛逛博客园或者csdn之类的网站罢了。学习的重要性我在这就不老生常谈了，大家读了这么多少年的书肯定就听了多少年，难就难在坚持。我去年考了复旦的在职硕士，今年考了软考的高级专业，信息系统项目管理师，为什么？因为我觉得我的知识不够用了，需要充电，需要接受更多的知识来帮助我达到我的职业规划目标，而这些考试，都是需要阅读大量的资料，学习大量的知识才能得以通过的，真心不容易！那么我的动力来自于哪里呢？就是来自于我的职业生涯规划。&lt;/p&gt;

&lt;p&gt;5年前我给我自己的职业生涯规划大致是这样的：程序员→软件工程师→项目主管→项目经理→项目总监→CIO，越向后面每一步所花的时间和所付出的努力就越大，也就是说，我现在已经到达了项目经理的位置，如果要向前再迈一步，我必须要付出可能比前三步还要多的时间和精力，而我目前的水平还远远够不上项目总监，那么怎么办？？学习！！！和修炼武功一样，只有通过学习理论以及将学到的知识应用到工作上产生经验的累积，才能让我真正的提升内功，达到下一个境界！&lt;/p&gt;

&lt;p&gt;我目前正在备考软件架构设计师，明年上半年准备考系统分析师（都是软考的高级考试），下半年考PMP，后年上半年准备硕士论文答辩（这也是职业规划的一部分）。我想等到后年，7年+工作经验，加上我的知识累积，去拿下项目总监的位子应该是不在话下了吧，这样我就又完成了职业生涯规划的一步了。我现在每天保持至少4小时的学习时间，来补习我的基础知识以及专业知识，而我学习的动力，很大程度上就是来自于我的职业规划，我一定要向前迈出那一步，就算再辛苦，再劳累，也无法阻挡我的脚步！因此，给自己的职业规划，其实也是一个很好的鞭笞你持续学习的理由，无论什么事情，就算再困难，一旦有了动力，我相信就会坚持下去的！&lt;/p&gt;

&lt;p&gt;说了很多，不知道我的意思大家能不能理解了，其实归纳一下，职业生涯规划是指导你，鞭笞你的工具，反过来也是你一步步需要去达成的目标，相辅相成，互相作用，最终的结果就是将你的内功修炼的炉火纯青，而你也可以凭借你强大的“武功”去获得你想要的一切！我希望所有看到这篇文章的软件从业者，特别是年轻的程序员们，都可以给自己做一份职业生涯规划，给自己定一条路线，让自己在这条路线上一步一步走下去。&lt;/p&gt;

&lt;p&gt;非常感谢大家看完我的文章，欢迎指出我的不足之处，和发表您的观点和评论！！&lt;/p&gt;

&lt;p&gt;2012.8.26 凌晨 by 熊绎&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/reserved/job/&quot;&gt;job&lt;/a&gt; was originally published by Ang Wei at &lt;a href=&quot;http://localhost:4000&quot;&gt;AngWei's homepage&lt;/a&gt; on October 26, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[老码农教你学英语]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/reserved/new-post/" />
  <id>http://localhost:4000/reserved/new-post</id>
  <published>2013-10-23T00:00:00+08:00</published>
  <updated>2013-10-23T00:00:00+08:00</updated>
  <author>
    <name>Ang Wei</name>
    <uri>http://localhost:4000</uri>
    <email>weiang123@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;转自：&lt;a href=&quot;http://blog.jobbole.com/45296/&quot;&gt;http://blog.jobbole.com/45296/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于咱们这些高端大气、时刻需要和国际接轨的码农，英语的重要性自然是毋庸置疑的。尤其是那些胸怀大志的潜在大牛们，想在码农行业闯出一片天地，秒杀身边的小弟们，熟练掌握英语更是实现其目标最关键的因素之一。否则，试想在你捧着某出版社刚刚翻译出来的《JSP 高效编程》苦苦学习JSP模板的时候，你旁边的小弟却是拿着原版的《AngularJS in Action》学习开发单页面应用，虽然你们都同样认真地学习了一个月，可做出来东西的效果能一样吗？&lt;/p&gt;

&lt;p&gt;所以，英语好才能学到最新最炫的技术，否则只能拿着国内出的翻译版学习两三年前的老古董还把它当个宝。更何况国内的翻译书水平如何你不会不知道吧？多少坑爹的翻译啊！不提了！其实我十多年前还参加过一本Java开发指南的翻译，而当时我一直在IBM主机上做开发，压根就不会Java，所以误人子弟是肯定的了。回首往事，惭愧啊！请上帝宽恕我的罪恶，阿门……&lt;/p&gt;

&lt;p&gt;好了，现在言归正传，说说码农应该如何学习英语，达到熟练掌握英语的水平。首先，我要明确一个概念：英语学习是不可能速成的。一心想速成的同学们可以不用往下看了，不然浪费了你们的时间我可担不起责任啊。&lt;/p&gt;

&lt;p&gt;作为码农的习惯，自然第一个重点是要准确定义”熟练掌握英语“的概念。&lt;/p&gt;

&lt;p&gt;我的定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 阅读：能够直接阅读英文文档，比如《MongoDB: The Definitive Guide》，并且阅读速度和理解程度都能与母语相当；
2. 写作：能够直接编写英文文档、邮件，达到英语母语人士能够无歧义理解的程度，学有余力的同学可以追求逻辑严密和用词严谨；
3. 听说：能够顺畅地与英语母语人士进行有关技术方面的交流，达到双方沟通无歧义的程度，学有余力的同学还可以争取在对话中表现幽默感和个人品位。 肯定有人要不服了：为啥学习的起点给俺整这么高呢？因为，只有达到这个标准，你才能充分发现学好英语的好处，也才能自觉地尽可能使用英语，形成良性循环。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么，要达到这个标准需要多少时间呢？对于CET-4或者6级水平的同学（没错，4和6都是一个水平，几乎没啥差别），我的估计是需要1万小时以上。这也是我前面说英语不可能速成的原因。可能有人会抱怨说，老码农你不靠谱，1万小时也太多了，就算一天花5小时学英语，也需要6年时间，这不是太坑爹了么？对此我想说的是，每天5小时其实一点也不难，如果你一直在学新技术而不是重复做熟练工的话，平均每天看技术文档就能看3小时，另外写文档邮件注释再花1小时，上下班路上也别坐着发呆，至少可以练听力1小时，这样5小时不就出来了么？&lt;/p&gt;

&lt;p&gt;最关键的是，这5小时并不是另外挤出来的，而只需要把以前的一些习惯改一改就好。遇到问题百度查中文文档改成Google查英文文档，把写中文注释的习惯改成写英文注释，拼音变量名改成英文短语变量名，尽量和国际接轨，做一个高端大气国际化的码农。除了这5小时之外，平时没事也可以听点外语歌，感受一下英语的韵律；有机会就经常去听一些国际性的行业大会；周末再去看看好莱坞原声版大片，不亦乐乎？这些都是你本来工作和生活中就有的内容，并不需要刻意地去挤很多时间苦学。只要有心，处处时时都是学习的机会。&lt;/p&gt;

&lt;p&gt;至于6年时间有人觉得太长，如果是你喜欢做的事，谁会嫌时间长? 更何况你往后看就会发现，这1万个小时里在学英语的同时也是在学技术，而且是最基础或者最先进的技术，是不学好英语就很难及时掌握的技术。通过这个过程，你不仅英语水平提高了，技术上也能大有长进。这些都是潜移默化的，每天都在进步，而不是一定要突击到满1万小时产生一个突然的飞跃，这才是真正提高水平的真谛所在。所以我认为，学英语首先要去掉功利心理，通过一个努力的过程把英语变成你的一项爱好：看书就喜欢看英文版的书，看电影就喜欢看原声不带字幕的。如果能做到这一点，别说6年，就是60年你也能甘之如饴；反之如果你不喜欢英语，那么每天5个小时的煎熬即使是6个月恐怕都很难坚持下来吧？&lt;/p&gt;

&lt;p&gt;写到这里，对于学习英语的心态，我想小结一下。有些同学会狠狠地下一个决心：我要开始学英语了！苦读一年练成英语神功！然后开始拿一本词典开始背单词，花了一个月时间把A打头的单词背得滚瓜烂熟，然后，就放弃了。。。我想说的是，不要把学英语看作一次磨练意志的马拉松赛跑，把它当做一次旅行，享受这个过程，享受途中的风景，不用急着赶路，这样你才能走得更远。&lt;/p&gt;

&lt;p&gt;言归正传，1万个小时这个数据的估算方法是：阅读5000小时、听2000小时、 写2000小时、 说1000小时，下面具体说明：&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;1. 大量阅读是提高英语水平的基础、核心、重中之重，要在大量阅读的基础上再开始练习听力和写作。&lt;/h3&gt;

&lt;p&gt;为什么这么说？最有效的学习方式就是模仿，而听说读写四个要素里只有听和读有模仿条件。&lt;/p&gt;

&lt;p&gt;那为什么不是先多听呢？有两个原因。一是口语比较随意，俚语方言比较多，在表达上不如书面内容严谨；二是听一次没能理解的内容不容易查找和重复。所以大量的阅读是提高英语水平的关键性基础性的工作。&lt;/p&gt;

&lt;p&gt;有人又要问了，难道不要先背单词吗？这个嘛，我自己是最讨厌背单词的，又怎么会把你们往火坑里推呢？而且单纯地背单词用处不大，在阅读中记住的单词才是有用的。&lt;/p&gt;

&lt;p&gt;比如在GRE单词表开头随便找个单词avalanche，释义是n.雪崩 vi.崩塌，你可以使劲地背，把它和其他几千个单词都记得滚瓜烂熟，然后当你某天在文档中看到一句话说：”… to handle an avalanche of client requests …“，你可能都想不起来背过avalanche这个单词，即使想起来也未必能准确理解它在这段话里的含义。&lt;/p&gt;

&lt;p&gt;这是为什么呢？因为背单词是孤立地去记一个个单词，应试也许有用，但是事倍功半。最好的方法就是在阅读中去理解它，比如还是那一句，我压根不知道avalanche这个单词，但是从前后文去蒙，an avalanche of大概是说非常多的意思，如果你不确定理解得对不对就去查一下字典，就明白了这意思是”像雪崩一样滚滚而来的大量的什么东西“。&lt;/p&gt;

&lt;p&gt;查词最好是查英-英辞典，比如Merriam-Webster的韦氏英英辞典。还有，查一个单词的时候，不要去记那几个中文释义。某些人背单词就喜欢像念经似的念叨：“capability，才能，能力，容量，性能，生产率，capability，才能，能力，容量，性能，生产率……”，旁观者都替他觉得累得慌对吧？其实你只要模糊地知道它的意思就行了，学英语尽量不要掺进来中文。老外不知道啥叫“才能，能力，容量，性能，生产率”，也没影响人家用capability这个词不是？&lt;/p&gt;

&lt;p&gt;另外我觉得吧，单词和人一样，也是有眼缘的，记得住记不住都不要去强求。即使这一次看完又忘了也没关系，等你阅读量上去之后，遇到次数多了自然就记住了。有人说，万一有的词遇到次数很少，还是记不住咋办？对这种问题我就无语了。遇到次数很少的单词你记它干啥？有个著名单词中文意思是什么早期银版照相术的，我就偏不记它，它能把我怎么着啊？&lt;/p&gt;

&lt;p&gt;通过这个过程，你不但记住了单词，还掌握了它的常见用法，这对于以后的写和说都是非常好的基础。现在很多人学英语的弊病在于应试思维，就仿佛孔乙己说的茴香豆的茴有四种写法，少记住一种就可能在考试里做错题被扣分，但是现实生活中你也许只需要会一种就行了，关键是知道它的意思而且能够准确地使用它。&lt;/p&gt;

&lt;p&gt;矮马，一下子扯到背单词跑偏了。还是接着说阅读，怎么阅读呢？我推荐一种暴力方法，不管你基础如何，先找一两本和技术相关的白话书，而且是你最感兴趣的领域，比如经典的《Man Month Myth》（人月神话） 和《Joel on Software》（大神Joel谈软件开发）原版书，这样读起来好歹不那么苦闷，有助于你坚持下来。毕竟在这个起步阶段，坚持是第一位的。不然给你找本《advanced econometrics》试试，据说95%的码农读了三天之后都疯了。&lt;/p&gt;

&lt;p&gt;就算是你感兴趣的书，也保不齐一开始读起来觉得很费劲。也许有的人翻开第一页一看，妈呀，一半单词不认识！这咋办？没事，像我前面说的，有把握蒙的就蒙，没把握的就查，查过的可以把中文意思写在单词旁边，能写英文理解更好，懒得写也没关系，总之原则就是把全部内容看懂吃透就行。&lt;/p&gt;

&lt;p&gt;还有，句子太长里边有好多that….. which….. who….什么的从句？那也没关系，别人理解不了，可咱是码农啊，懂得嵌套结构的原理，不就是递归嘛！甭管他连了多少个，从最后面的那个往前一个一个处理，把从句用彩笔一个一个标出来，最后看清楚嵌套关系以后，句子也就容易看懂了。实际上，我觉得英语最妙的地方就在这里，它能在一个句子里用一个无限延展的树形结构来描述一个概念，直到把它定义得非常严谨无歧义为止。中文做不到这一点，必须拆成好多个句子才能做到通顺，但理解起来就困难多了。&lt;/p&gt;

&lt;p&gt;在这个阶段一定不要求快，一天吭哧吭哧地只看了半页都没关系，也很正常，但一定要确保准确理解。在此我想特别提醒的是，如果你一开始不适应，一定要坚持下来。其实学习英语过程中最难的不是听说读写，而是英语思维。汉语是讲朦胧美的，所谓“道可道，非常道”，越深刻的东西往往越是“只可意会，不可言传”，文人写文章喜欢下结论而很少论证，结论的经验性主观性较大，例如“肉食者鄙，未能远谋”；而欧美文章则大多务求精确严谨，定义精确，论证充分，避免逻辑上的漏洞，下结论则往往比较谨慎，一般都是客观数据，尽量避免主观看法，例如“根据卫星云图，明天的降水概率为70%”。我年轻的时候买过《孙子兵法》和克劳塞维茨的《战争论》一起看，两者的风格差别真是泾渭分明。&lt;/p&gt;

&lt;p&gt;此外对于人文方面也有很大差别。老外经过文艺复兴，对于人文关怀有了很好的基础，更强调个人自由和权利，所谓”风能进，雨能进，国王不能进”；我们从历史文化传承的角度看则是集体大于个人，更强调个人适应环境。再比如老外对于弱势群体的歧视嘲笑是非常忌讳的，但中国人往往习惯了小品里瘸子瞎子胖子出场摔一大跟头这样的笑料。&lt;/p&gt;

&lt;p&gt;所以，这些思维上的差异才是学英语的最大障碍，而大量阅读有助于理解和养成这种思维习惯。特别是逻辑上的严密性和表达的客观性方面，由于文化传统和教师本身的原因，在中国现在的教育环境很难训练出来。但是通过大量阅读英语材料，就可以达到很好的洗脑效果，实为居家旅行、和平演变必备良药。&lt;/p&gt;

&lt;p&gt;读完两三本白话书就算是热好身了，下面可以开始读一些更枯燥的东西，主要是专业教课书。如果上大学的时候学的《数据结构》、《离散数学》、《操作系统》这些都还给老师了，正好拿英文版的复习一下。找你专业相关的基础课原版教材，5本左右，开练。照着前面的要求，一样细细地看，不求快但求精，练习题也好好做一部分，不然你怎么知道自己确实理解透了？&lt;/p&gt;

&lt;p&gt;等你看完这几本，阅读基本上就算入门了，可以开始练习写作和听力。具体做法后面再细说。&lt;/p&gt;

&lt;p&gt;与此同时，要开始看一些行业里最新的技术文档。这些可能还没出书，也可能有一些免费的pdf，不管怎样，也找5本左右来看，什么MongoDB，Neo4j，Node.js，AngularJS之类的，细细地看，边看边做个系统练手，因为这些新技术文档还比较少，社区里的东西也不多，所以免不了要去StackOverflow问，或者去GitHub找些例子来看，别偷懒，这些都是很好的学习方式。&lt;/p&gt;

&lt;p&gt;等你把这几本书也啃下来以后，按A4纸算，你的阅读量肯定会达到7000页以上，在SO, GitHub, Google上查看过的英文资料也不会少于3000页，阅读总量肯定超过1万页了。现在恭喜你，你的阅读能力肯定没问题了。如果我没猜错的话，你这时候碰到翻译版的书都懒得瞟一眼，更别说花钱买和花时间读了。&lt;/p&gt;

&lt;p&gt;另外，阅读能力达到这个水平以后，写作也基本有个基础了。所谓“熟读唐诗三百首，不会作诗也会吟”，看多了以后你会发现英语写作也有一些套路，和中文是一个道理，经过大量的阅读，很多句式其实已经在你的脑子里了，只要在写作过程中经常练习这些句式，自然就熟能生巧了。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2. 写作要创造环境，每天都要写1000字以上。&lt;/h3&gt;

&lt;p&gt;在互联网时代，这一点也不难。最简单直接的办法就是注册一个StackOverflow账号，起初是去问问题，把你搞不定的代码贴上去，会有大牛们帮你搞定，顺带着阅读也练了；等你技术水平涨了以后，想想这么多人帮了你你才成了大牛，总不能只进不出吧，有余力了就应该报复社会，所以就经常去StackOverflow找一些你拿手的主题，帮其他菜鸟们解答一些问题，这样也就练了写作了，一举两得多好！&lt;/p&gt;

&lt;p&gt;等你在SO上混出了点名堂，有点江湖地位的时候，就会有人来找你，比如帮忙干点活啊咨询点问题啊之类的，自然邮件联系就少不了了，这都是练习写作的机会，就算你不想帮他干活，也可以和他扯一扯。&lt;/p&gt;

&lt;p&gt;另外，弄个翻墙软件比如goagent，注册个Google Plus账号，上去看看热点文章，写点自己的体会之类的。实在闲得无聊也可以找Linus之类的大牛混，他每发一贴你就上去评论一番或者请教一下，先混个脸熟嘛！顺带也练习了写作。时间长了，说不定大牛还喜欢上你了，没准随便给你个肉身翻墙的机会，这就是意外之喜了。&lt;/p&gt;

&lt;p&gt;总之，写作是大量阅读之后水到渠成的产物，不过要注意一点，写出来的每个句子甚至每个单词都要务求精准地道，不知道的不要瞎写，要么改换自己熟悉的写法，要么查清楚了再写。要是养成随意乱写的习惯，写出来的句子都是中国人能看懂，外国人都看不懂，那前面的努力就付诸东流了。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;3. 听力要在阅读能力达到一定水平后再开始练习，和前面说的阅读给写作打基础的关系相似，练听力的同时其实就在为口语打基础。&lt;/h3&gt;

&lt;p&gt;我首先要说的是，千万不要跟着美剧什么的练听力，你又不是打算偷渡去纽约皇后区卖毒品跟黑人大哥混，就算你听一耳朵就能熟练分辨出说WTF are you doing的是意大利人、爱尔兰人还是黑人，又有啥用呢？咱们做码农的一定不要忘了自己的本分，得跟着码农的大哥混才对。所以练习听力一定要多找IT圈的大牛的访谈来听。&lt;/p&gt;

&lt;p&gt;最经典的自然是天妒英才英年早逝的乔帮主，多听听他的访谈你就知道他的成功绝非偶然。像这样一位逻辑严密，思维活跃，表达能力强，善于调动听众情绪，还很有幽默感，而且做事又非常有韧性的人，实在是百年难遇的天才人物。&lt;/p&gt;

&lt;p&gt;比尔盖茨的访谈就差多了，他的表达能力真的是不敢恭维，有时候东拉西扯的听不明白重点，依稀有点韩乔生老师的风韵。政客系列也不推荐，像奥巴马的讲演听起来总有一种似曾相识的赶脚，细细一想，这不就是美国版的传销讲座嘛！&lt;/p&gt;

&lt;p&gt;所以，多听乔大神的访谈绝对是没错的。为啥是访谈呢？因为都是对话，形式上和咱们的需求匹配，咱们工作中需要的英语对话就是类似于访谈式的，你想想是不是？而且他的访谈聊的都是咱们挨踢的事儿，背景知识都比较熟悉，你专心听他的表达和逻辑就好了。你要是不服，俺给你弄个生物系教授讲分子生物学课程的录音让你听，你听完还能找得到北吗？&lt;/p&gt;

&lt;p&gt;这些访谈在网上都有，到iTunes里的podcast里大把大把的，不过别找带字幕的听，千万！&lt;/p&gt;

&lt;p&gt;现在材料有了，怎么听呢？我先告诉你，每个访谈都要听100遍以上，头20遍就是稀里糊涂地听，能听懂多少听懂多少，听不懂的先蒙。但我敢保证，第20遍肯定比第1遍听懂的东西要多多了。到了20遍还在蒙的，基本你听到第100遍也还是在蒙，所以再蒙下去就没意义了，这时候找到文字版好好看一遍，就看一遍，然后收起来，再听20遍，这时候有些原来靠蒙的就听出来了，听完20遍再看一次，再听，如此反复，100遍之后基本应该都不用蒙了，然后再听下一个。听过100遍的，以后也要经常复习，反复听，再背几遍，很多句型就会自动进到你的脑子里，给你的口语打下一个很好的基础。&lt;/p&gt;

&lt;p&gt;IT界的访谈每个大概都在1-2小时之间，就算1.5小时吧。一个听100遍就是150小时，精听10个就是1500小时。10个就够了，不用追求数量，关键是重复。当然平时还要有一些泛听，比如英文广播、看CNN新闻什么的，越多越好，这些就不求全听懂，听懂多少是多少，一遍就过去，权当是个消遣。&lt;/p&gt;

&lt;p&gt;在这之后，再故意去找一些录音不是那么清晰的访谈来听，比如乔大神96年回到Apple时，在当年的WWDC上的访谈。这个访谈很有意思，因为他一回来就砍掉了好多正在做的产品，有很多利益受损的听众对他不服不忿的，带讽刺挖苦甚至攻击性的问题也不少，可乔大神应对自如，潇洒极了。这个访谈大概是因为年代久远，杂音比较多，音质也不太好，但仔细听也能听出来。很好，就是它了！就照着这个标准找那么三、四个略模糊的访谈，比如通过电话进行的一些访谈，再如法炮制，按100遍的方法听它500小时，这样听力基本也就过关了。&lt;/p&gt;

&lt;p&gt;有人大概心里会嘀咕：故意找这种模糊的录音听有什么意义呢？这主要是让你适应不那么理想环境下的听力，比如在喧闹的餐厅里对话，或者是老外通过skype对你进行电话面试，而你只能听清专业录音设备录下来的访谈，那咋行？所以也需要在前面理想条件下1500小时听力练习完成的基础上，训练一下恶劣条件下的听力。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;4. 练习口语是最麻烦的，因为说的条件最难创造，这必须得有个大活人认真地跟你聊才行啊！&lt;/h3&gt;

&lt;p&gt;当然了，要是你能找个英语母语的老外谈对象，那就又省事又高效了。不过，等口语练好了一定要一脚将其踹掉。要记住，你是一个中国人，肥水不流外国田！&lt;/p&gt;

&lt;p&gt;好了，大晚上的不扯淡了。练习英语口语不外乎这么几个途径：交外国朋友，进外国公司，或者花钱雇外国人跟你聊。各人工作、经济情况不同，这就自己选择吧。反正现在改革开放了，一部分人也富起来了，跟谁聊也就丰俭由人了。&lt;/p&gt;

&lt;p&gt;不过这里要提醒一点，别去什么英语角练口语，这种地方要么是一百多人围着一个老外，跟看猴似的，要么就是一堆中国人互相来几句好肚油肚，听着就想摸摸对方的肚子看看有多好有多油，纯粹浪费时间！我认为，练口语一定要找英语是母语的人士练习，这样才能事半功倍。&lt;/p&gt;

&lt;p&gt;另外，有机会就多去美国英国澳大利亚加拿大什么的地方转转，现场体验一下自己的学习成果。不过我这里讲的主要是码农工作相关的东西，基本没涉及到生活类的英语，比如去麦当劳买个milk shake什么的，这些主要要靠现场体验现场学习，但有了前面阳春白雪的码农高端上流社会英语作为基础，这些下里巴人的生活英语上手很快，对你肯定不在话下。&lt;/p&gt;

&lt;p&gt;【补充】有同学想让我推荐一些学习材料，我后来补充了一篇补充一些英语学习素材，供大家参考。&lt;/p&gt;

&lt;p&gt;关于码农如何学好英语，我就先说这么多吧。最后再总结一下，英语学习是一个终身的事业，只有通过痛苦的起步阶段，慢慢把它变成你的一个爱好，才能持久下去。等到它真正成为你喜爱的东西了，你就会发现眼中的世界从此变得不同。它变大了，变得多样化了，也变得更美好了。这时，所有的努力和坚持都有了回报。&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/reserved/new-post/&quot;&gt;老码农教你学英语&lt;/a&gt; was originally published by Ang Wei at &lt;a href=&quot;http://localhost:4000&quot;&gt;AngWei's homepage&lt;/a&gt; on October 23, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[回车(carriage return)和换行(line feed)有什么区别]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/reserved/rn/" />
  <id>http://localhost:4000/reserved/rn</id>
  <published>2013-10-18T00:00:00+08:00</published>
  <updated>2013-10-18T00:00:00+08:00</updated>
  <author>
    <name>Ang Wei</name>
    <uri>http://localhost:4000</uri>
    <email>weiang123@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;转自：&lt;a href=&quot;http://javaeye-mao.iteye.com/blog/211354&quot;&gt;http://javaeye-mao.iteye.com/blog/211354&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;‘\r’是回车，’\n’是换行，前者使光标到行首，后者使光标下移一格。通常用的Enter是两个加起来。下面转一篇文章。
回车和换行 &lt;/p&gt;

&lt;p&gt;今天，我总算搞清楚“回车”（carriage return）和“换行”（line feed）这两个概念的来历和区别了。 
在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。 &lt;/p&gt;

&lt;p&gt;于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。 &lt;/p&gt;

&lt;p&gt;这就是“换行”和“回车”的来历，从它们的英语名字上也可以看出一二。 &lt;/p&gt;

&lt;p&gt;后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。 &lt;/p&gt;

&lt;p&gt;Unix系统里，每行结尾只有“&lt;换行&gt;”，即“\n”；Windows系统里面，每行结尾是“&lt;换行&gt;&lt;回车&gt;”，即“\n\r”；Mac系统里，每行结尾是“&lt;回车&gt;”。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。 &lt;/回车&gt;&lt;/回车&gt;&lt;/换行&gt;&lt;/换行&gt;&lt;/p&gt;

&lt;p&gt;c语言编程时（windows系统）\r 就是return 回到 本行 行首 这就会把这一行以前的输出 覆盖掉 
如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int main() { 
	cout &amp;lt;&amp;lt; &quot;hahaha&quot; &amp;lt;&amp;lt; &quot;\r&quot; &amp;lt;&amp;lt; &quot;xixi&quot; ; 
}  最后只显示 

xixi 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而 hahaha 被覆盖了 &lt;/p&gt;

&lt;p&gt;\n 是回车＋换行 把光标 先移到 行首 然后换到下一行 也就是 下一行的行首拉 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int main() { 
	cout &amp;lt;&amp;lt; &quot;hahaha&quot; &amp;lt;&amp;lt; &quot;\n&quot; &amp;lt;&amp;lt; &quot;xixi&quot; ; 
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;则 显示 &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hahaha 
xixi
&lt;/code&gt;&lt;/pre&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/reserved/rn/&quot;&gt;回车(carriage return)和换行(line feed)有什么区别&lt;/a&gt; was originally published by Ang Wei at &lt;a href=&quot;http://localhost:4000&quot;&gt;AngWei's homepage&lt;/a&gt; on October 18, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Greedy Algorithms]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/algorithms%20design/greedy-algorithms/" />
  <id>http://localhost:4000/algorithms%20design/greedy-algorithms</id>
  <published>2013-10-16T00:00:00+08:00</published>
  <updated>2013-10-16T00:00:00+08:00</updated>
  <author>
    <name>Ang Wei</name>
    <uri>http://localhost:4000</uri>
    <email>weiang123@gmail.com</email>
  </author>
  <content type="html">

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/algorithms%20design/greedy-algorithms/&quot;&gt;Greedy Algorithms&lt;/a&gt; was originally published by Ang Wei at &lt;a href=&quot;http://localhost:4000&quot;&gt;AngWei's homepage&lt;/a&gt; on October 16, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Five Steps to Successful Writing]]></title>
  <link rel="alternate" type="text/html" href="http://localhost:4000/technical%20writing/five-steps-to-successful-writing/" />
  <id>http://localhost:4000/technical%20writing/five-steps-to-successful-writing</id>
  <published>2013-10-16T00:00:00+08:00</published>
  <updated>2013-10-16T00:00:00+08:00</updated>
  <author>
    <name>Ang Wei</name>
    <uri>http://localhost:4000</uri>
    <email>weiang123@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;Successful writing on the job is not the product of inspiration, nor is it
memrly the spoken word converted to print; It is the result of knowing how to structure information using both text and design to achieve an intended purpose for a clearly defined audience.&lt;/p&gt;

&lt;h3 id=&quot;approach-writing-using-the-following-steps&quot;&gt;Approach writing using the following steps&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1. Preparation
2. Research
3. Organization
4. Writing
5. Revision
&lt;/code&gt;&lt;/pre&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/technical%20writing/five-steps-to-successful-writing/&quot;&gt;Five Steps to Successful Writing&lt;/a&gt; was originally published by Ang Wei at &lt;a href=&quot;http://localhost:4000&quot;&gt;AngWei's homepage&lt;/a&gt; on October 16, 2013.&lt;/p&gt;</content>
</entry>

</feed>
